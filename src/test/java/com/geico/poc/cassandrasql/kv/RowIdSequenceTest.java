package com.geico.poc.cassandrasql.kv;

import com.geico.poc.cassandrasql.QueryService;
import com.geico.poc.cassandrasql.dto.QueryResponse;
import com.geico.poc.cassandrasql.kv.KvTestBase;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

import java.util.*;
import java.util.concurrent.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test rowid sequence generation for tables without explicit primary keys.
 * 
 * This test verifies:
 * 1. Tables without PRIMARY KEY get a hidden 'rowid' column
 * 2. rowid values are auto-generated using an Accord-backed sequence
 * 3. rowid values are unique and monotonically increasing
 * 4. rowid generation works correctly under concurrent inserts
 */
@SpringBootTest
@TestPropertySource(properties = {
    "cassandra.storage-mode=kv",
    "cassandra.contact-points=localhost",
    "cassandra.port=9042",
    "cassandra.local-datacenter=datacenter1",
    "cassandra.keyspace=cassandra_sql"
})
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class RowIdSequenceTest extends KvTestBase {

    @Autowired
    private QueryService queryService;

    @Autowired
    private SchemaManager schemaManager;

    private String TEST_TABLE;

    @BeforeEach
    public void setup() throws Exception {
        TEST_TABLE = uniqueTableName("test_no_pk");

        // Clean up
        try {
            queryService.execute("DROP TABLE IF EXISTS " + TEST_TABLE);
            Thread.sleep(200);
        } catch (Exception e) {
            // Ignore
        }
    }

    @AfterEach
    public void cleanup() throws Exception {
        try {
            queryService.execute("DROP TABLE IF EXISTS " + TEST_TABLE);
            Thread.sleep(100);
        } catch (Exception e) {
            // Ignore
        }
    }

    // ========================================
    // Test 1: Create table without PRIMARY KEY
    // ========================================

    @Test
    @Order(1)
    public void testCreateTableWithoutPrimaryKey() throws Exception {
        System.out.println("\n=== Test 1: Create table without PRIMARY KEY ===");
        
        // Create table without PRIMARY KEY (like pgbench_history)
        QueryResponse createResp = queryService.execute(
            "CREATE TABLE " + TEST_TABLE + " (tid INT, bid INT, aid INT, delta INT, mtime TIMESTAMP, filler CHAR(22))"
        );
        
        assertNull(createResp.getError(), "CREATE TABLE should succeed: " + createResp.getError());
        
        // Verify table was created with hidden rowid column
        TableMetadata table = schemaManager.getTable(TEST_TABLE);
        assertNotNull(table, "Table should exist");
        
        List<String> pkColumns = table.getPrimaryKeyColumns();
        assertEquals(1, pkColumns.size(), "Should have 1 primary key column (rowid)");
        assertEquals("rowid", pkColumns.get(0).toLowerCase(), "Primary key should be rowid");
        
        // Verify rowid column exists
        boolean hasRowIdColumn = table.getColumns().stream()
            .anyMatch(col -> col.getName().equalsIgnoreCase("rowid"));
        assertTrue(hasRowIdColumn, "Table should have rowid column");
        
        System.out.println("✅ Table created with hidden rowid column");
    }

    // ========================================
    // Test 2: Insert rows and verify rowid auto-generation
    // ========================================

    @Test
    @Order(2)
    public void testRowIdAutoGeneration() throws Exception {
        System.out.println("\n=== Test 2: rowid auto-generation ===");
        
        // Create table
        queryService.execute(
            "CREATE TABLE " + TEST_TABLE + " (id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, name TEXT, age INT)"
        );
        Thread.sleep(100);
        
        // Insert rows without specifying rowid
        QueryResponse insert1 = queryService.execute(
            "INSERT INTO " + TEST_TABLE + " (name, age) VALUES ('Alice', 30)"
        );
        assertNull(insert1.getError(), "INSERT should succeed");
        
        QueryResponse insert2 = queryService.execute(
            "INSERT INTO " + TEST_TABLE + " (name, age) VALUES ('Bob', 25)"
        );
        assertNull(insert2.getError(), "INSERT should succeed");
        
        QueryResponse insert3 = queryService.execute(
            "INSERT INTO " + TEST_TABLE + " (name, age) VALUES ('Charlie', 35)"
        );
        assertNull(insert3.getError(), "INSERT should succeed");
        
        // Query and verify rowid values
        QueryResponse selectResp = queryService.execute("SELECT * FROM " + TEST_TABLE);
        assertNull(selectResp.getError(), "SELECT should succeed");
        assertEquals(3, selectResp.getRows().size(), "Should have 3 rows");
        
        // Extract rowid values
        Set<Long> rowIds = new HashSet<>();
        for (Map<String, Object> row : selectResp.getRows()) {
            Object rowidObj = row.get("id");
            assertNotNull(rowidObj, "Each row should have a row id");
            
            Long rowid = ((Number) rowidObj).longValue();
            rowIds.add(rowid);
            System.out.println("  Row: name=" + row.get("name") + ", rowid=" + rowid);
        }
        
        // Verify uniqueness
        assertEquals(3, rowIds.size(), "All rowid values should be unique");
        
        // Verify monotonically increasing (rowids should be 1, 2, 3)
        List<Long> sortedRowIds = new ArrayList<>(rowIds);
        Collections.sort(sortedRowIds);
        assertEquals(1L, sortedRowIds.get(0).longValue(), "First rowid should be 1");
        assertEquals(2L, sortedRowIds.get(1).longValue(), "Second rowid should be 2");
        assertEquals(3L, sortedRowIds.get(2).longValue(), "Third rowid should be 3");
        
        System.out.println("✅ rowid values are unique and monotonically increasing");
    }

    // ========================================
    // Test 3: Concurrent inserts generate unique rowids
    // ========================================

    @Test
    @Order(3)
    public void testConcurrentRowIdGeneration() throws Exception {
        System.out.println("\n=== Test 3: Concurrent rowid generation ===");
        
        // Create table
        queryService.execute(
            "CREATE TABLE " + TEST_TABLE + " (id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, data INT)"
        );
        Thread.sleep(100);
        
        int numThreads = 10;
        int insertsPerThread = 5;
        ExecutorService executor = Executors.newFixedThreadPool(numThreads);
        CountDownLatch latch = new CountDownLatch(numThreads);
        
        Set<Long> allRowIds = Collections.synchronizedSet(new HashSet<>());
        
        for (int i = 0; i < numThreads; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    for (int j = 0; j < insertsPerThread; j++) {
                        System.out.println("INSERTING INTO " + TEST_TABLE + " (data) VALUES (" + ((threadId * 100) + j) + ")");
                        queryService.execute(
                            "INSERT INTO " + TEST_TABLE + " (data) VALUES (" + ((threadId * 100) + j) + ")"
                        );
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    latch.countDown();
                }
            });
        }
        
        assertTrue(latch.await(30, TimeUnit.SECONDS), "All threads should complete");
        executor.shutdown();
        
        // Query all rows
        QueryResponse selectResp = queryService.execute("SELECT * FROM " + TEST_TABLE);
        assertNull(selectResp.getError(), "SELECT should succeed");
        
        int expectedRows = numThreads * insertsPerThread;
        assertEquals(expectedRows, selectResp.getRows().size(), 
            "Should have " + expectedRows + " rows");
        
        // Extract all rowid values
        for (Map<String, Object> row : selectResp.getRows()) {
            Long rowid = ((Number) row.get("id")).longValue();
            allRowIds.add(rowid);
        }
        
        // Verify all rowids are unique
        assertEquals(expectedRows, allRowIds.size(), 
            "All " + expectedRows + " rowid values should be unique");
        
        System.out.println("✅ Concurrent inserts generated " + allRowIds.size() + " unique rowids");
    }

    // ========================================
    // Test 4: pgbench_history table (real-world example)
    // ========================================

    @Test
    @Order(4)
    public void testPgBenchHistoryTable() throws Exception {
        System.out.println("\n=== Test 4: pgbench_history table ===");
        
        // Create pgbench_history table (no PRIMARY KEY in original)
        QueryResponse createResp = queryService.execute(
            "CREATE TABLE "+TEST_TABLE+"(id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, tid INT, bid INT, aid INT, delta INT, mtime TIMESTAMP, filler CHAR(22))"
        );
        
        assertNull(createResp.getError(), "CREATE TABLE should succeed: " + createResp.getError());
        
        // Insert sample data
        queryService.execute(
            "INSERT INTO "+TEST_TABLE+" (tid, bid, aid, delta) VALUES (1, 1, 1, 100)"
        );
        queryService.execute(
            "INSERT INTO "+TEST_TABLE+" (tid, bid, aid, delta) VALUES (1, 1, 2, 200)"
        );
        queryService.execute(
            "INSERT INTO "+TEST_TABLE+" (tid, bid, aid, delta) VALUES (1, 1, 3, 300)"
        );
        
        // Query data
        QueryResponse selectResp = queryService.execute("SELECT * FROM "+TEST_TABLE+"");
        assertNull(selectResp.getError(), "SELECT should succeed");
        assertEquals(3, selectResp.getRows().size(), "Should have 3 rows");
        
        // Verify rowids are unique
        Set<Long> rowIds = new HashSet<>();
        for (Map<String, Object> row : selectResp.getRows()) {
            Long rowid = ((Number) row.get("id")).longValue();
            rowIds.add(rowid);
            System.out.println("  Row: tid=" + row.get("tid") + ", aid=" + row.get("aid") + 
                             ", delta=" + row.get("delta") + ", rowid=" + rowid);
        }
        
        assertEquals(3, rowIds.size(), "All rowid values should be unique");
        
        // Clean up
        queryService.execute("DROP TABLE pgbench_history");
        
        System.out.println("✅ pgbench_history table works correctly");
    }

    // ========================================
    // Test 5: Sequence persists across table recreate
    // ========================================

    @Test
    @Order(5)
    public void testSequencePersistence() throws Exception {
        System.out.println("\n=== Test 5: Sequence persistence ===");
        
        // Create table and insert rows
        queryService.execute("CREATE TABLE " + TEST_TABLE + " (id SERIAL PRIMARY KEY, data INT)");
        Thread.sleep(100);
        
        queryService.execute("INSERT INTO " + TEST_TABLE + " (data) VALUES (1)");
        queryService.execute("INSERT INTO " + TEST_TABLE + " (data) VALUES (2)");
        queryService.execute("INSERT INTO " + TEST_TABLE + " (data) VALUES (3)");
        System.out.println("INSERTED 3 ROWS");

        // Get table ID
        TableMetadata table1 = schemaManager.getTable(TEST_TABLE);
        long tableId1 = table1.getTableId();
        
        // Drop table
        queryService.execute("DROP TABLE " + TEST_TABLE);
        Thread.sleep(100);
        System.out.println("DROPPED TABLE");

        
        // Recreate table (will get new table ID)
        queryService.execute("CREATE TABLE " + TEST_TABLE + " (id SERIAL PRIMARY KEY, data INT)");
        Thread.sleep(100);
        System.out.println("RE-CREATED TABLE");

        
        // Insert rows
        queryService.execute("INSERT INTO " + TEST_TABLE + " (data) VALUES (10)");
        queryService.execute("INSERT INTO " + TEST_TABLE + " (data) VALUES (20)");
        System.out.println("INSERTED 2 ROWS");

        // Get new table ID
        TableMetadata table2 = schemaManager.getTable(TEST_TABLE);
        long tableId2 = table2.getTableId();
        
        assertNotEquals(tableId1, tableId2, "New table should have different table ID");
        
        // Query rows
        QueryResponse selectResp = queryService.execute("SELECT id, data FROM " + TEST_TABLE);
        for(Map<String, Object> row : selectResp.getRows()) {
            System.out.println("Row: " + row);
        }
        assertEquals(2, selectResp.getRows().size(), "Should have 2 rows");
        
        // Verify rowids start from 1 again (new sequence for new table)
        Set<Long> rowIds = new HashSet<>();
        for (Map<String, Object> row : selectResp.getRows()) {
            Long rowid = ((Number) row.get("id")).longValue();
            rowIds.add(rowid);
        }
        
        assertTrue(rowIds.contains(1L), "Should have rowid=1");
        assertTrue(rowIds.contains(2L), "Should have rowid=2");
        
        System.out.println("✅ Each table has its own rowid sequence");
    }
}



